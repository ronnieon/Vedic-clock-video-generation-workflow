# S3 Sync - File Existence Behavior

## Overview

The S3 sync **never overwrites existing files**. It only transfers files that don't exist at the destination.

## Detailed Behavior

### Download Phase (S3 ‚Üí Local)

For each file in S3:

1. ‚úÖ **Check**: Does the file exist locally?
2. **If YES** (file exists locally):
   - ‚è≠Ô∏è **Skip** download
   - Increment `files_skipped_download` counter
   - Continue to next file
3. **If NO** (file doesn't exist locally):
   - ‚¨áÔ∏è **Download** the file from S3
   - Create parent directories if needed
   - Increment `files_downloaded` counter
   - Log: `‚¨áÔ∏è  Downloaded from S3: {filename}`

### Upload Phase (Local ‚Üí S3)

For each local file:

1. ‚úÖ **Check**: Does the file exist in S3?
   - Uses `head_object` API call (doesn't download the file)
2. **If YES** (file exists in S3):
   - ‚è≠Ô∏è **Skip** upload
   - Increment `files_skipped_upload` counter
   - Continue to next file
3. **If NO** (file doesn't exist in S3):
   - ‚¨ÜÔ∏è **Upload** the file to S3
   - Increment `files_uploaded` counter
   - Log: `‚¨ÜÔ∏è  Uploaded to S3: {filename}`

## Example Scenarios

### Scenario 1: Fresh Setup (Empty Local Directory)
```
S3 has: file1.png, file2.png, file3.png
Local has: (empty)

Result:
- Downloads: 3 files (file1.png, file2.png, file3.png)
- Uploads: 0 files
- Skipped: 0 files

Log: S3 sync completed: ‚¨áÔ∏è  3 downloaded, ‚¨ÜÔ∏è  0 uploaded, ‚è≠Ô∏è  0 skipped
```

### Scenario 2: New Local Files
```
S3 has: file1.png, file2.png
Local has: file1.png, file2.png, file3.png (new)

Result:
- Downloads: 0 files
- Uploads: 1 file (file3.png)
- Skipped Download: 2 files (file1.png, file2.png)
- Skipped Upload: 2 files (file1.png, file2.png)

Log: S3 sync completed: ‚¨áÔ∏è  0 downloaded, ‚¨ÜÔ∏è  1 uploaded, ‚è≠Ô∏è  4 skipped
```

### Scenario 3: Background Processor Results
```
S3 has: file1.png, file2.png, image_v5.png (generated by processor)
Local has: file1.png, file2.png

Result:
- Downloads: 1 file (image_v5.png - new version from processor)
- Uploads: 0 files
- Skipped Download: 2 files
- Skipped Upload: 2 files

Log: S3 sync completed: ‚¨áÔ∏è  1 downloaded, ‚¨ÜÔ∏è  0 uploaded, ‚è≠Ô∏è  4 skipped
```

### Scenario 4: Everything in Sync
```
S3 has: file1.png, file2.png, file3.png
Local has: file1.png, file2.png, file3.png

Result:
- Downloads: 0 files
- Uploads: 0 files
- Skipped Download: 3 files
- Skipped Upload: 3 files

Log: S3 sync: All files in sync (‚è≠Ô∏è  6 files already exist)
```

## Important Notes

### ‚úÖ What This Prevents
- **No duplicate transfers**: Files are never re-uploaded or re-downloaded
- **Bandwidth savings**: Only new files are transferred
- **Time savings**: Sync cycles complete quickly when in sync
- **No overwrites**: Existing files are never replaced

### ‚ö†Ô∏è What This Means
- **Local changes win**: If you modify a file locally, it won't be overwritten from S3
- **S3 changes win**: If a file changes in S3, it won't be re-downloaded (since it already exists locally)
- **No conflict resolution**: The first version (wherever it appears first) stays
- **No timestamp checking**: Newer files don't replace older ones

### üîÑ When Files ARE Transferred

**Download happens when**:
- File exists in S3
- File does NOT exist locally
- Example: Background processor created `image_v5.png` in S3

**Upload happens when**:
- File exists locally
- File does NOT exist in S3
- Example: You queued a prompt file `image_edit_prompt_for_v3.txt`

## Monitoring

### Log Messages

#### Successful Transfer
```
‚¨áÔ∏è  Downloaded from S3: download/page_0001/image_v5.png
‚¨ÜÔ∏è  Uploaded to S3: download/page_0001/image_edit_prompt_for_v3.txt
```

#### Sync Summary (with transfers)
```
S3 sync completed: ‚¨áÔ∏è  5 downloaded, ‚¨ÜÔ∏è  3 uploaded, ‚è≠Ô∏è  1000 skipped
```

#### Sync Summary (all in sync)
```
S3 sync: All files in sync (‚è≠Ô∏è  1500 files already exist)
```

#### Errors
```
Failed to download s3://contentextract/extract/file.png: Access Denied
Failed to upload /extracted/file.mp4 to S3: Network timeout
```

## Performance

### API Calls Per Sync Cycle

**Download Phase**:
- 1x `list_objects_v2` (paginated) - lists all S3 files
- Nx `download_file` - only for files that don't exist locally

**Upload Phase**:
- Mx `head_object` - checks each local file (lightweight, doesn't download)
- Px `upload_file` - only for files that don't exist in S3

Where:
- N = number of new files in S3
- M = number of local files
- P = number of new local files

### Typical Performance
```
1000 files in sync:
- Download phase: 1 list API call + 0 downloads = ~1-2 seconds
- Upload phase: 1000 head_object calls + 0 uploads = ~5-10 seconds
- Total: ~6-12 seconds per cycle
```

### With New Files
```
1000 files, 5 new in S3, 3 new locally:
- Download phase: 1 list + 5 downloads = ~3-5 seconds
- Upload phase: 1003 head_object + 3 uploads = ~6-15 seconds
- Total: ~9-20 seconds per cycle
```

## Advanced: Force Re-sync

If you need to force a file to be re-synced:

### Force Download
Delete the local file, then wait for next sync cycle:
```bash
rm extracted/download/page_0001/image_v5.png
# Wait 60 seconds, file will be re-downloaded from S3
```

### Force Upload
Delete from S3 (using AWS console or CLI), then wait for next sync cycle:
```bash
aws s3 rm s3://contentextract/extract/download/page_0001/image_v5.png
# Wait 60 seconds, file will be re-uploaded from local
```

## Future Enhancement: Timestamp-Based Sync

If you need files to be overwritten when newer versions exist, you could enhance the sync to:

1. Compare modification timestamps
2. Download if S3 file is newer than local
3. Upload if local file is newer than S3

This would require:
- Storing timestamps in S3 metadata
- Comparing `LastModified` (S3) vs `os.path.getmtime()` (local)
- Additional logic to determine which version wins

Not currently implemented to avoid accidental overwrites.
